# -*- shell-script -*-

#
# Collected shell (bash) utilities.  This is a collection of shell
# utilities I've used in building software, maintaining my systems and
# doing simple data processing at the shell.
#
# author: Kyle Burton <kyle.burton@gmail.com>
#
#  http://github.com/kyleburton/profile
#

#
# xargs grep:  find . -type f | xargs grep some-token
#
function xg () {
  xargs grep "$@"
}

# find file, filter out paths to commonly ignore, scm files and editor backup / swap files
function _ff_common_filter () {
  grep -vE '/(.git|CVS|.svn)/' | grep -vE '.swp(/|$)' | grep -v '/.rsync_cache/'
}

#
# 'find files': find . -type f
#
# NB: in each of these 'find' commands, if the first argument exists a
# directory, it is taken as the location to search, the next argument
# is taken as the pattern (when a pattern is used) and any remaining
# arguments are passed to the last command in the pipeline.
#
function ff () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type f "$@" | _ff_common_filter
}


# find files, xargs grep, like a grep -R, but ignores git and svn files
function ffxg () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type f -print0 | xargs -0 grep "$@" | _ff_common_filter
  
}

#
# Find files named 'X', where 'X' is automatically surrounded by
# wildcards so it can occurr anywhere within the name of the files.
#
#   find . -type f -name '*X*'
#
function ffn () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type f -name "*$1*" | _ff_common_filter
}

function ffns () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find $(cat .source-dirs) -type f -name "*$1*" | _ff_common_filter
}

function ffclj () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type f -name "*$1*.clj" | _ff_common_filter
}

function ffjava () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type f -name "*$1*.java" | _ff_common_filter
}

# case insensitive version of ffn
function ffni () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type f -iname "*$1*" | _ff_common_filter
}

# 'find directories'
function fd () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type d "$@" | _ff_common_filter
}

# find directories named
function fdn () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type d -name "*$1*" | _ff_common_filter
}

# case insensitive version of fdn
function fdni () {
  DIR="."
  if [ -d "$1" ]; then
    DIR="$1"
    shift
  fi
  find "$DIR" -type d -iname "*$1*" | _ff_common_filter
}


function viffn () {
  vi $(ffn "$@")
}

# various maven shortcuts
function mvno  () {
  mvn -o "$@"
}

#
# Shell based data processing utilities, these all use standard unix
# utilities that nearly all expect tab-delimited input and produce tab
# delimited output.
#

# Header preseving grep, very useful for database table dumps as well as delimited and fixed width data files.
function hgrep () {
  FILE="$1"
  shift
  (head -n 1 "$FILE"; tail -n +2 "$FILE" | grep "$@")
}

function hgrepi () {
  FILE="$1"
  shift
  (head -n 1 "$FILE"; tail -n +2 "$FILE" | grep -i "$@")
}

# header preserving sort
function hsort () {
  FILE="$1"
  shift
  (head -n 1 "$FILE"; tail -n +2 "$FILE" | sort "$@")
}

# header preserving tail
function htail () {
  FILE="$1"
  shift
  (head -n 1 "$FILE"; tail -n +2 "$FILE" | tail "$@")
}

# test if any of the given files (or directories) exist
function any_exists () {
  if [ -z "$1" ]; then
    return -1
  fi
  if [ -e "$1" ]; then
    return 0
  fi

  shift
  any_exists $@
}

# jump back to project root
function proot () {
  # project root is defined as the first directory (going back toward the root)
  # containing one of the following
  #   .git
  #   Makefile, makefile
  #   Rakefile
  #   pom.xml
  FILES=".git Makefile makefile Rakefile pom.xml"
  if any_exists $FILES; then
    echo "Project Root: `pwd`"
    return
  fi

  if [ "$(pwd)" == "$HOME" ]; then
    echo "Project Root not found"
    return
  fi

  cd ..
  proot
}

function mroot () {
  FILES=".git pom.xml"
  if any_exists $FILES; then
    echo "Maven Project Root: `pwd`"
    return
  fi

  if [ "$(pwd)" == "$HOME" ]; then
    echo "Maven Project Root not found"
    return
  fi

  cd ..
  proot
}

function is_osx () {
  uname -a | grep -q ^Darwin
}

function is_gnome () {
  uname -a | grep -q ^Linux && ps aux | grep -q [g]nome-session
}

function open_file () {
  if is_osx; then
    open "$@"
  elif is_gnome; then
    gnome-open "$@"
  else
    echo "Error(krb-bash-functions:open_file): unknown platform? => `uname -a`"
  fi
}

function _ensure_gem_installed () {
  local name
  name=$1
  if ! gem list | grep -q $name; then
    gem install $name
  fi
}

function view_markup () {
  FILE="$1"

  echo "$FILE ${FILE#*.}"
  if [ "md" = "${FILE#*.}" ]; then
    echo "treating $FILE as markdown (maruku)"
    _ensure_gem_installed maruku
    maruku "$FILE"
    OUT_FILE="`basename $1 .md`.html"
    open_file "$OUT_FILE"
    return $?
  fi

  if [ "textile" = "${FILE#*.}" ]; then
    echo "treating $FILE as textile (redcloth)"
    OUT_FILE="`basename $1`.html"
    _ensure_gem_installed RedCloth
    redcloth "$FILE" > "$OUT_FILE"
    open_file "$OUT_FILE"
    return $?
  fi

  echo "Not a recognized markup type, just invoking open_file($FILE)"
  open_file "$FILE"
}

function swank () {
  PORT="${1:-4005}"
  if [ -e project.clj ]; then
    slime-connect "$PORT" &
    lein deps; lein swank "$PORT"
  elif [ -e pom.xml ]; then
    slime-connect "$PORT" &
    if [ -e patch.dev.pom.xml.patch ]; then
      cp pom.xml dev.pom.xml
      patch -p0 < patch.dev.pom.xml.patch
      mvn -Dclojure.swank.port=$PORT -f dev.pom.xml clojure:swank
    else
      mvn -Dclojure.swank.port=$PORT clojure:swank
    fi
  else
    echo "Sorry: don't know how to run a swank server in $(pwd)"
  fi
}

alias gg='git grep'
alias s='cd ..'
alias rm='rm -i'
alias mv='mv -i'

################################################################################
## TODO: LS Color Options (at least for OSX, need to see if these work on Linux too)
BLACK=a
RED=b
GREEN=c
BROWN=d
BLUE=e
MAGENTA=f
CYAN=g
LIGHT_GREY=h
BOLD_BLACK_USUALLY_SHOWS_UP_AS_DARK_GREY=A
BOLD_RED=B
BOLD_GREEN=C
BOLD_BROWN_USUALLY_SHOWS_UP_AS_YELLOW=D
BOLD_BLUE=E
BOLD_MAGENTA=F
BOLD_CYAN=G
BOLD_LIGHT_GREY__LOOKS_LIKE_BRIGHT_WHITE=H
DEFAULT_FOREGROUND_OR_BACKGROUND=x

function set_ls_colors_osx_default () {
  export LS_COLOR_DIRECTORY="$BLUE$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_SYMBOLIC_LINK="$BOLD_MAGENTA$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_SOCKET="$GREN$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_PIPE="$BROWN$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_EXECUTABLE="$RED$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_BLOCK_SPECIAL="$BLUE$CYAN"
  export LS_COLOR_CHARACTER_SPECIAL="$BLUE$BROWN"
  export LS_COLOR_EXECUTABLE_WITH_SETUID_BIT_SET="$BLACK$RED"
  export LS_COLOR_EXECUTABLE_WITH_SETGID_BIT_SET="$BLACK$CYAN"
  export LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITH_STICKY_BIT="$BLACK$GREN"
  export LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITHOUT_STICKY_BIT="$BLACK$BROWN"
  export LSCOLORS="$LS_COLOR_DIRECTORY$LS_COLOR_SYMBOLIC_LINK$LS_COLOR_SOCKET$LS_COLOR_PIPE$LS_COLOR_EXECUTABLE$LS_COLOR_BLOCK_SPECIAL$LS_COLOR_CHARACTER_SPECIAL$LS_COLOR_EXECUTABLE_WITH_SETUID_BIT_SET$LS_COLOR_EXECUTABLE_WITH_SETGID_BIT_SET$LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITH_STICKY_BIT$LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITHOUT_STICKY_BIT"
}

function set_ls_colors_osx_dark_background () {
  export LS_COLOR_DIRECTORY="$CYAN$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_SYMBOLIC_LINK="$BOLD_MAGENTA$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_SOCKET="$GREN$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_PIPE="$BROWN$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_EXECUTABLE="$RED$DEFAULT_FOREGROUND_OR_BACKGROUND"
  export LS_COLOR_BLOCK_SPECIAL="$BLUE$CYAN"
  export LS_COLOR_CHARACTER_SPECIAL="$BLUE$BROWN"
  export LS_COLOR_EXECUTABLE_WITH_SETUID_BIT_SET="$BLACK$RED"
  export LS_COLOR_EXECUTABLE_WITH_SETGID_BIT_SET="$BLACK$CYAN"
  export LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITH_STICKY_BIT="$BLACK$GREN"
  export LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITHOUT_STICKY_BIT="$BLACK$BROWN"
  export LSCOLORS="$LS_COLOR_DIRECTORY$LS_COLOR_SYMBOLIC_LINK$LS_COLOR_SOCKET$LS_COLOR_PIPE$LS_COLOR_EXECUTABLE$LS_COLOR_BLOCK_SPECIAL$LS_COLOR_CHARACTER_SPECIAL$LS_COLOR_EXECUTABLE_WITH_SETUID_BIT_SET$LS_COLOR_EXECUTABLE_WITH_SETGID_BIT_SET$LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITH_STICKY_BIT$LS_COLOR_DIRECTORY_WRITABLE_TO_OTHERS_WITHOUT_STICKY_BIT"
}


set_ls_colors_osx_dark_background

# enable cut/paste to/from clipboard on X, like on the mac
if which xsel 2>&1 > /dev/null; then
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi

export PATH="$PATH:/usr/local/scala/bin"

bind "set completion-ignore-case off" 2>/dev/null

# not for OSX...
# alias ls='ls --color=auto -Fa'
export CLICOLOR=1
alias ls='ls -Fa --color=auto'


rn_changed_repos () {
  if [ -s "$HOME/.rn/changed-projects" ]; then
    printf "CHANGES EXIST IN: [$(cat $HOME/.rn/changed-projects)]
    "
  else
    echo ""
  fi  
}

if ! echo "$PS1" | grep -q "rn_changed_repos"; then
  export PS1="\$(rn_changed_repos)$PS1"
fi

rn_pair_name () {
  echo $(grep 'name = ' ~/.gitconfig | cut -f2 -d '=')
}

if ! echo "$PS1" | grep -q "rn_pair_name"; then
  export PS1="[\$(rn_pair_name)] $PS1"
fi
